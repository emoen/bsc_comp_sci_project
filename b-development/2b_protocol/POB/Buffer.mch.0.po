THEORY PropertiesX IS
  ctx(Buffer) => ctx(Bool_TYPE);
  ctx(Bool_TYPE) => BOOL = {FALSE , TRUE};
  ctx(Bool_TYPE) => card(BOOL) = 2
END
&
THEORY EnumerateX IS
  binhyp(ctx(Bool_TYPE)) => BOOL == {FALSE , TRUE}
END
&
THEORY NotEqualX IS
  binhyp(BOOL = {FALSE , TRUE}) & binhyp(card(BOOL) = 2) => not(FALSE = TRUE);
  binhyp(BOOL = {FALSE , TRUE}) & binhyp(card(BOOL) = 2) => not(TRUE = FALSE)
END
&
THEORY RewriteToFalseOrTrueX IS
  binhyp(BOOL = {FALSE , TRUE}) & binhyp(card(BOOL) = 2) => FALSE = TRUE == false;
  binhyp(BOOL = {FALSE , TRUE}) & binhyp(card(BOOL) = 2) => TRUE = FALSE == false
END
&
THEORY FwdContra0X IS
  TRUE = FALSE & ctx(Bool_TYPE) => bfalse;
  x = TRUE & x = FALSE & ctx(Bool_TYPE) => bfalse;
  x = TRUE & y = x & y = FALSE & ctx(Bool_TYPE) => bfalse;
  x = FALSE & x = TRUE & ctx(Bool_TYPE) => bfalse;
  x = FALSE & y = x & y = TRUE & ctx(Bool_TYPE) => bfalse
END
&
THEORY FwdEqual1X IS
  FALSE = x => x = FALSE;
  TRUE = x => x = TRUE;
  not(FALSE = x) & ctx(Bool_TYPE) => x = TRUE;
  not(x = FALSE) & ctx(Bool_TYPE) => x = TRUE;
  not(TRUE = x) & ctx(Bool_TYPE) => x = FALSE;
  not(x = TRUE) & ctx(Bool_TYPE) => x = FALSE
END
&
THEORY ExpandHypX IS
  inv(Buffer) => inv(Bool_TYPE);
  inv(Buffer) => contents : seq(ITEM);
  inv(Buffer) => size(contents) <= maxsize;
  cst(Buffer) => card(ITEM) : NAT1;
  cst(Buffer) => maxsize : NAT;
  pre(add) => ee : ITEM
END
&
THEORY Initialisation IS
  cst(Buffer) & ctx(Buffer) => <> : seq(ITEM);
  cst(Buffer) & ctx(Buffer) => size(<>) <= maxsize
END
&
THEORY binit IS
  cst(Buffer) & ctx(Buffer) & inv(Buffer) & asn(Buffer) & pre(binit) => <> : seq(ITEM);
  cst(Buffer) & ctx(Buffer) & inv(Buffer) & asn(Buffer) & pre(binit) => size(<>) <= maxsize
END
&
THEORY add IS
  cst(Buffer) & ctx(Buffer) & inv(Buffer) & asn(Buffer) & pre(add) => (size(contents) < maxsize => contents <- ee : seq(ITEM));
  cst(Buffer) & ctx(Buffer) & inv(Buffer) & asn(Buffer) & pre(add) => (size(contents) < maxsize => size(contents <- ee) <= maxsize)
END
&
THEORY initial
END
&
THEORY remove IS
  cst(Buffer) & ctx(Buffer) & inv(Buffer) & asn(Buffer) & pre(remove) => (not(contents = <>) => tail(contents) : seq(ITEM));
  cst(Buffer) & ctx(Buffer) & inv(Buffer) & asn(Buffer) & pre(remove) => (not(contents = <>) => size(tail(contents)) <= maxsize)
END
&
THEORY Context
END
&
THEORY Assertions
END
&
THEORY Constraints IS
  ( #ITEM.(card(ITEM) : NAT1) )
END
